---
title: "latent: an R library for Latent Variable Modeling"
date: "2025-11-18"
author: "Marcos Jimenez, Mauricio Garnier-Villarreal, & Vithor Rosa Franco"

format:
  revealjs:
    slide-level: 1         # use level 1 headings (#) as individual slides
    number-sections: false
    toc: false
    theme: simple          # change if you prefer another revealjs theme
    code-fold: true        # folds code blocks (click to expand)
    code-overflow: scroll
    output: true
    slide-number: true    # show slide numbers
    css: styles.css
    width: 1400      # wider slides
    height: 800      # 16:9 aspect
    margin: 0.02     # less empty border around the slide
fontsize: 18pt
bibliography: references.bib
---

# Table of contents

- [Latent Variable Modeling](#latent-variable-model)
- [Latent Class Analysis](#latent-class-analysis-lca)
- [Current software limitations for Latent Variable Modeling](#current-software-limitations-for-latent-variable-modeling)
- [The latent R package](#the-latent-r-package)
- [Unified and flexible syntax](#unified-and-flexible-syntax)
- [First step: Install and load the package](#first-step:-install-and-load-the-package)
- [Categorical indicator example](#categorical-indicator-example)
- [Model Fit Indices](#model-fit-indices)
- [Classification Diagnostics](#classification-diagnostics)
- [References](#references)

# Latent Variable Modeling

A latent variable model is a way of connecting things we can measure directly
(called observed or manifest variables) to hidden qualities we cannot measure
directly (called latent variables). These models are used in many areas like
biology, computer science, and social sciences. Latent variable models can 
involve either categorical or continuous observed and hidden variables, as below:

``` {r table01, echo=FALSE}
library(knitr)
library(kableExtra)

latent_table <- data.frame(
  "Latent variables" = c("Continuous", "Categorical"),
  "Continuous (Manifest)" = c("Factor Analysis", "Latent Profile Analysis"),
  "Categorical (Manifest)" = c("Item Response Theory", "Latent Class Analysis"),
  check.names = FALSE
)

knitr::kable(latent_table, "html", caption = NULL) |>
  kableExtra::kable_styling(full_width = FALSE, position = "center")
```

<br>

![](figures/diagram.jpg){height=300px fig-align="center"}

# Current software limitations for Latent Variable Modeling

- Commercial software (e.g., Mplus) is either expensive or not open-source (e.g., LatenGOLD).
- Free and open-source alternatives (e.g., poLCA, depmixS4, lavaan, mirt) are computationally slow and support a limited range of models.

![](figures/thinking.jpg){width=15% style="vertical-align:middle; margin-right:0.5em;"} So… what are we doing about it?

# Current software limitations for Latent Variable Modeling

- Commercial software (e.g., Mplus) is either expensive or not open-source (e.g., LatenGOLD).
- Free and open-source alternatives (e.g., poLCA, depmixS4, lavaan, mirt) are computationally slow and support a limited range of models.

![](figures/thinking.jpg){width=15% style="vertical-align:middle; margin-right:0.5em;"} So… what are we doing about it?

We are building a free, open-source, efficient, and flexible software. ![](figures/pirate.jpg){width=15% style="vertical-align:middle; margin-right:0.5em;"}

# The latent R package

```{r eval=TRUE, echo=FALSE}
library(latent)
```

::: {.columns}
::: {.column width="70%"}

- Few arguments for a straightforward analysis  
- lavaan syntax for Structural Equation Models
- Customizable models
- Core functions written in C++ with the armadillo library
- Parallelization of multiple random starts to address local maxima  

![](figures/load.jpg){width=300%}

:::
::: {.column width="30%"}
![](figures/standard.jpg){width=300%}
:::
:::

# Unified and flexible syntax

::: {.columns}
::: {.column width="70%"}

- Few arguments for an straightforward analysis  

```{r eval=FALSE, echo=TRUE}
lca(data, nclasses = 1:3)
```

- `lavaan` syntax for Structural Equation Models

```{r eval=FALSE, echo=TRUE}
HS.model <- ' visual  =~ x1 + x2 + x3
              textual =~ x4 + x5 + x6
              speed   =~ x7 + x8 + x9 '
fit <- lcfa(model = HS.model, data = HolzingerSwineford1939)
```

- Customizable models

```{r eval=FALSE, echo=TRUE}
lca(data, nclasses = 1:3, model = NULL)
```

:::
::: {.column width="30%"}
![](figures/fixing.jpg){width=300%}
:::
:::

# High-performance computing

::: {.columns}
::: {.column width="70%"}

<!-- <details markdown="1"> -->
<!-- <summary>High-performance computing</summary> -->

- Core functions written in C++ with the armadillo library

![](figures/armadillo.jpg){width=150%}

- Parallelization of multiple random starts to address local maxima  
![](figures/local_maxima.jpg){width=30%}

<!-- </details> -->

:::
::: {.column width="30%"}
![](figures/fast.jpg){width=300%}

:::
:::

# First step: Install and load the package

While several functions are already implemented in `latent`, there are still
some necessary improvements before it can be submitted to *CRAN*. Therefore,
you have to follow the installation instructions from the *GitHub* repository: [https://github.com/Marcosjnez/latent](https://github.com/Marcosjnez/latent). If you are using Linux or Windows, the following code should be enough. If you are using Mac, please refer to the repository on additional details that may be necessary.

``` {r eval=FALSE, echo=TRUE}
devtools::install_github("marcosjnez/latent", force = TRUE)
library(latent)
```

::: {.columns}
::: {.column width="50%"}
![](figures/load.jpg){width=200%}
:::
::: {.column width="50%"}
![](figures/mac.jpg){width=200%}
:::
:::

# Latent Class Analysis

Latent class analysis (LCA) is an umbrella term that refers to a number
of techniques for estimating unobserved group membership based on a
parametric model of one or more observed indicators of group membership.

People belong to different groups (i.e., classes) that are not directly observable. 
There are two types of parameter:

- The probability that a person belongs to a particular class $k$: $P(\theta_k)$.

- The conditional probability (density) of a response to item $j$ if a person belongs to the class $k$: $f(y_j\mid \theta_k)$.

The likelihood of a response pattern is given by
$$
\ell \;=\; \sum_{k=1}^{K} P(\theta_k)\, \prod_{j=1}^J f(y_j\mid \theta_k).
$$

# Categorical indicator example

For this analysis, we will employ the **gss82** example data set included in
the `latent` package. Sourced from the `poLCA` package, this data comes from
1,202 respondents to the 1982 General Social Survey.

Inspect the data:
``` {r eval=TRUE, echo=TRUE}
# Variables:
lapply(gss82, unique)
```

# Categorical indicator example

For this analysis, we will employ the **gss82** example data set included in
the `latent` package. Sourced from the `poLCA` package, this data comes from
1,202 respondents to the 1982 General Social Survey.

Model fitting:
``` {r eval=TRUE, echo=FALSE}
set.seed(2025)
```
``` {r eval=TRUE, echo=TRUE, results='hide', message=FALSE}
fit <- lca(data = gss82, nclasses = 3,
           item = rep("multinomial", ncol(gss82)))
fit
```
``` {r eval=TRUE, echo=FALSE}
fit
```

# Categorical indicator example

For this analysis, we will employ the **gss82** example data set included in
the `latent` package. Sourced from the `poLCA` package, this data comes from
1,202 respondents to the 1982 General Social Survey.

Fit information:
``` {r eval=TRUE, echo=TRUE}
fit@loglik 
fit@penalized_loglik 
fit@Optim$opt$iterations
fit@Optim$opt$convergence 
fit@timing
```

# Model Fit indices

The `getfit` function is used for extracting several fit indices for the model.

```{r eval=TRUE, echo=TRUE}
## Get fit indices
latent::getfit(fit)
```

# Profile table

The profile table contains the model parameter estimates.

``` {r eval=TRUE, echo=TRUE}
latInspect(fit, what = "profile")
```

# Classification Diagnostics

`latent` has a `latInspect` function that allows the user to extract information fro the model. For example, with the argument `what` equal to
`"state"`, the function will return the predicted class membership of each person.

```{r eval=TRUE, echo=TRUE, collapse=TRUE}
latInspect(fit, what = "state")
```

Posterior probabilities:
```{r eval=TRUE, echo=TRUE, collapse=TRUE}
latInspect(fit, what = "posterior")
```

Table with fit information by response pattern:
```{r eval=TRUE, echo=TRUE, collapse=TRUE}
round(latInspect(fit, what = "table"), 3)
```

# Confidence intervals

One can also extract the estimated confidence intervals using
the dedicated function `ci`. The result returned from the function is the same as 
the `profile` output from the `latInspect` function, but this time including the confidence limits.

```{r eval=TRUE, echo=TRUE, collapse=TRUE}
## Get confidence intervals
CI <- ci(fit, type = "standard", model = "model",
         confidence = 0.95, digits = 2)
CI$table
```

<!-- On the probability scale: -->
<!-- ```{r eval=TRUE, echo=TRUE, collapse=TRUE} -->
<!-- ## Get confidence intervals -->
<!-- CI <- ci(fit, type = "standard", model = "user", -->
<!--          confidence = 0.95, digits = 2) -->
<!-- CI$table -->
<!-- ``` -->

# Comparison with the `poLCA` library

The `poLCA` library uses the Expectation-Maximization algorithm to fit LCA models with polytomous variables.

Fit the model:
```{r eval=TRUE, echo=TRUE, collapse=TRUE}
library(poLCA)
f <- cbind(PURPOSE, ACCURACY, UNDERSTA, COOPERAT)~1
poLCAfit <- poLCA(f, gss82, nclass=3, maxiter=8000) 
```

Time ratio:
```{r eval=TRUE, echo=TRUE}
poLCAfit$time[[1]] / fit@timing
```

# Scalability of `latent`

For a given dataset, the time to convergence is linear in the number of classes.

![](figures/scalability.jpg){height=400px fig-align="center"}

# Continuous indicator example

::: {.columns}
::: {.column width="70%"}

Model fitting:
```{r eval=TRUE, echo=TRUE, results='hide'}
fit <- lca(data = empathy[, 1:6], nclasses = 4L,
           item = rep("gaussian", ncol(empathy[, 1:6])))

fit@loglik                # -1841.336
fit@penalized_loglik      # -1844.333
fit@Optim$opt$iterations  # 49
fit@Optim$opt$convergence # TRUE
fit@timing                # 0.2064401
```

Model information:
```{r eval=FALSE, echo=TRUE}
# Plot model fit info:
fit

# Get fit indices:
getfit(fit)

# Inspect model objects:
latInspect(fit, what = "coefs", digits = 3)
latInspect(fit, what = "classes", digits = 3)
latInspect(fit, what = "profile", digits = 3)
latInspect(fit, what = "posterior", digits = 3)

# Get confidence intervals:
CI <- ci(fit, type = "standard", model = "user",
         confidence = 0.95, digits = 2)
CI$table
```

:::
::: {.column width="30%"}
![](figures/standard.jpg){width=300%}
:::
:::

# Continuous indicator example

::: {.columns}
::: {.column width="70%"}

Model fitting:
```{r eval=FALSE, echo=TRUE}
fit <- lca(data = empathy[, 1:6], nclasses = 4L,
           item = rep("gaussian", ncol(empathy[, 1:6])))

fit@loglik                # -1841.336
fit@penalized_loglik      # -1844.333
fit@Optim$opt$iterations  # 49
fit@Optim$opt$convergence # TRUE
fit@timing                # 0.2064401
```

Profile output:
```{r eval=TRUE, echo=TRUE}
latInspect(fit, what = "profile", digits = 3)
```

:::
::: {.column width="30%"}
![](figures/standard.jpg){width=300%}
:::
:::

# Mixed indicators example

::: {.columns}
::: {.column width="60%"}

Model fitting:
```{r eval=FALSE, echo=TRUE}
fit <- lca(data = cancer[, 1:6], nclasses = 3L,
           item = c("gaussian", "gaussian",
                    "multinomial", "multinomial",
                    "gaussian", "gaussian"))
fit@loglik                # -5784.701
fit@penalized_loglik      # -5795.573
fit@Optim$opt$iterations  # 111
fit@Optim$opt$convergence # TRUE
fit@timing                # 0.1927969
```

Model information:
```{r eval=FALSE, echo=TRUE}
# Plot model fit info:
fit

# Get fit indices:
getfit(fit)

# Inspect model objects:
latInspect(fit, what = "coefs", digits = 3)
latInspect(fit, what = "classes", digits = 3)
latInspect(fit, what = "profile", digits = 3)
latInspect(fit, what = "posterior", digits = 3)

# Get confidence intervals:
CI <- ci(fit, type = "standard", model = "user",
         confidence = 0.95, digits = 2)
CI$table
```

:::
::: {.column width="40%"}
![](figures/standard.jpg){width=300%}
:::
:::

# Speed Comparison with the depmixS4 library

# Two-step LCA analysis with covariates

::: {.columns}
::: {.column width="60%"}

- Step 1, fit the measurement model without the covariates:
```{r eval=FALSE, echo=TRUE}
# Covariates:
X <- empathy[, 7:8]
names(X)

# Measurement model:
fit0 <- lca(data = data, nclasses = 4L
            item = rep("gaussian", ncol(data)))
```

- Step 2, fit the model with covariates fixing the measurement part:
```{r eval=FALSE, echo=TRUE}
# Structural model:
fit <- lca(data = data, X = X, model = fit0
           item = rep("gaussian", ncol(data)),
           nclasses = 4L)
fit@timing
fit@loglik                # -1798.885
fit@penalized_loglik      # -1801.996
fit@Optim$opt$iterations
fit@Optim$opt$convergence
```

:::
::: {.column width="40%"}
![](figures/diagram_covariates.jpg){height=600px fig-align="center"}
:::
:::

# Class Enumeration

# Factor Analysis

::: {.columns}
::: {.column width="60%"}

Factor Analysis (FA) is a method that estimates the influence of $K$ continuous
latent variables on a set of $J$ items.

The score in item $j$ is a weighted sum of the $K$ latent factors:
$$
X_j = \sum_{k=1}^K \lambda_{jk}F_k + \epsilon_j.
$$

Under some assumptions, the $J$ regressions can be encoded in a model for the 
covariance matrix of the items:

$$
S = \Lambda \Psi \Lambda^\top + \Theta.
$$

- $\Lambda$ is a $J \times K$ matrix containing the regression coefficients.

- $\Psi$ is the correlation matrix between the $K$ latent factors.

- $\Theta$ is the error covariance matrix.

:::
::: {.column width="40%"}
![](figures/diagram_factor.jpg){height=600px fig-align="center"}
:::
:::

# Multigroup Analysis

::: {.columns}
::: {.column width="60%"}

```{r, eval=FALSE, echo=TRUE}
model <- 'visual  =~ x1 + x2 + x3
          textual =~ x4 + x5 + x6
          speed   =~ x7 + x8 + x9'

fit <- lcfa(HolzingerSwineford1939, model = model, group = "school", 
            estimator = "ml", std.lv = TRUE)
fit@loglik 
fit@penalized_loglik 
fit@loss 
fit@Optim$opt$iterations
fit@Optim$opt$convergence
fit@timing
```

:::
::: {.column width="40%"}
![](figures/diagram_holzinger.jpg){height=600px fig-align="center"}
:::
:::

# Positive-definite constraints

In the factor model equation,
$$
\Lambda \color{red}{\Psi} \Lambda^\top + \color{red}{\Theta},
$$

Latent correlations$\color{red}{\Psi}$ and covariances $\color{red}{\Theta}$ should be at least positive-semidefinite but…

![](figures/nonpositive.jpg){width=600px}

# Positive-definite constraints (`lavaan` fails)

Let's force an instance where lavaan fails to converge to a proper solution.

::: {.columns}
::: {.column width="70%"}

```{r, eval=FALSE, echo=TRUE}
model <- 'visual  =~ x1 + x2 + x3
          textual =~ x4 + x5 + x6
          speed   =~ x7 + x8 + x9
          x1 ~~ x5
          x1 ~~ x4
          x4 ~~ x5
          x4 ~~ x6'

fit2 <- cfa(model, data = HolzingerSwineford1939,
            estimator = "ml", std.lv = TRUE, std.ov = TRUE)
inspect(fit2, what = "est")$theta      # Error covariances
det(inspect(fit2, what = "est")$theta) # Check the determinant
```

:::
::: {.column width="30%"}
![](figures/diagram_holzinger_errors.jpg){height=600px fig-align="center"}
:::
:::

# Positive-definite constraints

::: {.columns}
::: {.column width="60%"}

- Parameterize the polychoric correlation matrix as a crossproduct:
$$
\Sigma = X^\top X
$$
- Constraint **X** to be **oblique**:
$$
X \in \mathbb{R}^{p\times p}: \text{diag}(X^\top X) = I
$$

$$
\begin{bmatrix}
\color{red}{0.04}   & \color{blue}{1.00}  & \color{green}{-0.40} \\
\color{red}{-0.95}  & \color{blue}{-0.07} & \color{green}{-0.40} \\
\color{red}{-0.32}  & \color{blue}{-0.04} & \color{green}{0.83}
\end{bmatrix}^\top 
\begin{bmatrix}
\color{red}{0.04}   & \color{blue}{1.00}  & \color{green}{-0.40} \\
\color{red}{-0.95}  & \color{blue}{-0.07} & \color{green}{-0.40} \\
\color{red}{-0.32}  & \color{blue}{-0.04} & \color{green}{0.83}
\end{bmatrix} = \begin{bmatrix}
1.00 & 0.11 & 0.10 \\
0.11 & 1.00 & -0.41 \\
0.10 & -0.41 & 1.00
\end{bmatrix}
$$
:::
::: {.column width="30%"}
![](figures/magician.jpg){width=300%}
:::
:::

# Positive-semidefinite latent covariances

::: {.columns}
::: {.column width="20%"}

![](figures/magic_trick.jpg){height=250px}

:::
::: {.column width="80%"}

- Parameterize latent covariances as crossproducts:

$$
\Psi = Y^\top Y \\
\Theta = U^\top U
$$

- Constraint **Y** and **U** to be **orthoblique**:
$$
X \in \mathbb{R}^{p\times p}: \text{diag}(X^\top X) = \text{sparse matrix}
$$

:::
:::

$$
\begin{bmatrix}
\color{red}{0.08} & \color{blue}{1.76} & \color{green}{0.04} \\
\color{red}{-1.95} & \color{blue}{-0.12} & \color{green}{-0.69} \\
\color{red}{-0.67} & \color{blue}{-0.08} & \color{green}{2.02}
\end{bmatrix}^\top \begin{bmatrix}
\color{red}{0.08} & \color{blue}{1.76} & \color{green}{0.04} \\
\color{red}{-1.95} & \color{blue}{-0.12} & \color{green}{-0.69} \\
\color{red}{-0.67} & \color{blue}{-0.08} & \color{green}{2.02}
\end{bmatrix} = \begin{bmatrix}
4.24 & 0.42 & 0.00 \\
0.42 & 3.11 & 0.00 \\
0.00 & 0.00 & 4.56
\end{bmatrix}
$$

# Positive-semidefinite latent covariances

::: {.columns}
::: {.column width="30%"}

![](figures/magic_trick.jpg){height=250px}

:::
::: {.column width="70%"}

```{r, eval=FALSE, echo=TRUE}
model <- 'visual  =~ x1 + x2 + x3
          textual =~ x4 + x5 + x6
          speed   =~ x7 + x8 + x9
          x1 ~~ x5
          x1 ~~ x4
          x4 ~~ x5
          x4 ~~ x6'

fit <- lcfa(data = HolzingerSwineford1939, model = model,
            estimator = "ml", positive = TRUE)
round(latInspect(fit, what = "theta")[[1]], 3)
det(latInspect(fit, what = "theta")[[1]])
```

:::
:::

# Work in progress

::: {.columns}
::: {.column width="60%"}

- (Exploratory) Structural Equation Modeling

- (Multidimensional) Item Response Theory

- Hidden Markov Models

Release date? Soon

Download the **beta version** at https://github.com/Marcosjnez/latent

**Contact:** m.j.jimenezhenriquez@vu.nl

![](figures/qr_repository.jpg){width=300px style="vertical-align:middle; margin-right:0.5em;"}

:::
::: {.column width="40%"}

![](figures/chef.jpg){width=1000px style="vertical-align:middle; margin-right:0.5em;"}

:::
:::
